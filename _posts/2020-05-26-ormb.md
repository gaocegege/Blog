---
layout: post
title: "ormb：像管理 Docker 容器镜像一样管理机器学习模型"
description: 
headline:
modified: 2020-05-26
category: 
tags: []
imagefeature:
mathjax: false
chart:
comments: true
featured: true
---

> 才云科技计划于 2020 年开始，逐渐开源云原生机器学习平台 Clever 的社区版，机器学习模型管理组件 [ormb][] 是第一个开源的组件。它能够像管理容器镜像一样管理机器学习模型。
>
> 它不仅能够提供版本化的模型管理能力，还可以利用符合 OCI 标准的容器镜像仓库存储和分发机器学习模型。同时，通过 Harbor 2.0 还可实现在多个镜像仓库间的同步，满足更多企业级的需求。

以 Docker 为代表的容器虚拟化技术，业已成为云计算的中流砥柱。世界各地的软件工程师们纷纷成为了它的拥趸。以 Open Container Initiative 作为基础，容器的生态迅速演化。Docker Compose，Kata Containers 等项目百花齐放，Kubernetes 更是成为了集群调度领域的事实标准。

回过头看，以 Docker 为代表的容器虚拟化技术，能够以雷霆万钧之势席卷世界，最大的依仗当属其镜像分发能力。这是其他技术一直以来不曾解决的问题，也是在应用部署场景下，一直以来引人诟病的问题。Docker 把 Build Once, Deploy Anywhere 的能力带给了传统应用场景。Java、NodeJS、Rust 等等各种各样的语言，各种各样的依赖库，都可以在本地一次构建成符合 OCI 规范的容器镜像，随后利用镜像仓库进行存储和分发。

Docker 很好地解决了传统应用分发的问题，那么在机器学习场景下，我们是否需要分发的能力？

## 为什么需要分发模型

机器学习场景与传统的应用场景相比，存在一定的差异，也正是这些差异导致了对分发能力的要求有一些偏差。在传统应用的场景下，需要分发的通常是二进制可执行程序，或者带有语言解释器的脚本代码，或者是带着语言虚拟机的字节码。而且，对于传统应用的场景，通常开发团队迭代的是代码，同一个版本的代码多次编译出来的输出工件是一致的。

而在机器学习场景下，情况就有些不同了。算法工程师在迭代开发的是模型（包括模型的结构和权重）。同一版本的训练代码，根据输入的数据和随机状态（Random State）的不同，也会产生不同的模型。在部署模型推理服务时，真正需要分发的内容也是模型。只要模型分发到服务器上，我们就可以利用 [Nvidia Triton Inference Server](https://github.com/NVIDIA/triton-inference-server)、[ONNX Runtime](https://github.com/microsoft/onnxruntime) 等成熟的开源模型服务器组件将模型以 gRPC 或者 RESTful API 的方式对外提供接口。

因此，**在机器学习场景下，与其说我们想分发应用，不如说我们想分发的是模型**。

## State of the Art

既然在机器学习场景下，模型的分发是我们关注的特性，那么这一特性也一定是不少模型仓库项目想要提供的。目前在业界，模型的分发问题主要有两种实现思路。

第一种是以 [Caicloud Clever](https://caicloud.io/products/clever) 第一代模型仓库为代表的维护自有存储的实现。用户需要通过 SDK 或者 UI 的方式，上传模型到模型仓库中。在模型上传后，模型仓库会将模型和模型的元数据存储在自身维护的存储后端中。在用户需要利用模型进行推理时，需要再利用模型仓库提供的 SDK 或者接口将模型下载下来，进行推理服务。

另外一种，是以 [ModelDB](https://github.com/VertaAI/modeldb) 为代表的实现。在这种实现中，模型仓库并不真正存储模型，而只存储模型的元数据。模型本身通过借助第三方的对象存储，如 MinIO，S3 等实现。模型存储的路径作为元数据之一，被模型仓库管理。在需要下载模型时，可以利用第三方的对象存储提供的 SDK 或者接口进行下载。

这两种方式各有优劣：前者可以更好地进行模型的权限控制，但是引入了私有的 SDK 和接口来进行模型的上传与下载，对用户而言有一定的学习成本。

后者利用成熟的第三方存储进行模型文件的保存，学习成本较低。但是元数据与模型分离的实现使得权限控制非常困难。用户通过第三方存储的 SDK 或者接口可以绕过模型仓库直接对模型文件进行下载。除此之外，两种方式都需要自己造轮子，来实现对模型的元数据和模型文件的处理逻辑。

那么，有没有结合两种实现的优点，同时又可以规避它们的缺点的设计方案呢？

## 利用镜像仓库分发机器学习模型

我们把目光投向了镜像仓库，镜像仓库已经是云原生时代的一个至关重要的基础设施了。它为容器镜像提供了标准化的分发能力，如果能够复用镜像仓库的能力来分发模型，这样不仅避免了重复造轮子，同时可以提供类似于 `docker pull` 与 `docker push` 的使用体验，对用户而言没有过多的学习成本。

于是，[ormb][] 应运而生。[ormb][]（哦，人民币）的名称源自 OCI-Based Registry for ML/DL Model Bundle，它能够将模型和模型的元数据利用已有的镜像仓库进行分发。

### 端到端的示例

接下来，我们以图像识别作为示例，介绍一下如何利用 [ormb][] 进行机器学习模型的分发。

在这一示例中，我们会在本地利用 [Fashion MNIST](https://github.com/zalandoresearch/fashion-mnist) 训练一个简单的 CNN 图像识别模型，并且利用 [ormb][] 将其推送到远端的镜像仓库中。随后，在服务器上我们同样利用 [ormb][] 将模型拉取下来，并且利用第三方的模型服务器对外提供服务。随后我们利用 RESTful 的接口调用这一服务，查看结果。

模型训练的代码如下所示，具体训练过程不再赘述，最后我们将训练好的模型保存为 SavedModel 格式。

```python
# 建立模型，设定 Optimizer，进行训练
model = keras.Sequential([
  keras.layers.Conv2D(input_shape=(28,28,1), 
                      filters=8, 
                      kernel_size=3, 
                      strides=2, 
                      activation='relu', 
                      name='Conv1'),
  keras.layers.Flatten(),
  keras.layers.Dense(10, 
                     activation=tf.nn.softmax, 
                     name='Softmax')
])
model.compile(optimizer='adam', 
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy'])
model.fit(train_images, train_labels, epochs=epochs)

test_loss, test_acc = model.evaluate(test_images, 
                                     test_labels)
import tempfile

# 保存模型到当前目录的 model 子目录下
MODEL_DIR = "./model"
version = 1
export_path = os.path.join(MODEL_DIR, str(version))
tf.keras.models.save_model(
    model,
    export_path,
    overwrite=True,
    include_optimizer=True,
    save_format=None,
    signatures=None,
    options=None
)
```

接下来，我们可以将在本地训练好的模型推送到远端 Harbor 镜像仓库中：

```bash
# 将模型保存在本地文件系统的缓存中
$ ormb save ./model gaocegege/fashion_model:v1
ref:     gaocegege/fashion_model:v1
digest:  6b08cd25d01f71a09c1eb852b3a696ee2806abc749628de28a71b507f9eab996
size:    162.1 KiB
v1: saved
# 将保存在缓存中的模型推送到远端模型仓库中
$ ormb push gaocegege/fashion_model:v1
The push refers to repository [gaocegege/fashion_model]
ref:     gaocegege/fashion_model:v1
digest:  6b08cd25d01f71a09c1eb852b3a696ee2806abc749628de28a71b507f9eab996
size:    162.1 KiB
v1: pushed to remote (1 layer, 162.1 KiB total)
```

在 Harbor 中，我们可以看到这一模型的元数据等。

<figure>
	<img src="{{ site.url }}/images/ormb/harbor.png" height="400" width="400">
    <figcaption>在 Harbor Portal 中查看模型</figcaption>
</figure>

## 与 Harbor 的集成

## 技术实现

## 后续计划

[ormb]: https://github.com/caicloud/ormb

## License

- This article is licensed under [CC BY-NC-SA 3.0](https://creativecommons.org/licenses/by-nc-sa/3.0/).
- Please contact me for commercial use.
